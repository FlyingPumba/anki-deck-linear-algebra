{
  "id": "29",
  "title": "Lesson 29: QR Decomposition and Numerical Stability",
  "lesson_title": "QR decomposition and numerical stability",
  "objectives": [
    "Understand QR decomposition deeply",
    "Compare QR vs SVD vs eigendecomposition",
    "Appreciate numerical stability"
  ],
  "cards": [
    {
      "uid": "linear-algebra-29-001",
      "front": "What is the QR decomposition?",
      "back": "Any \\( m \\times n \\) matrix \\( A \\) (\\( m \\geq n \\)) can be written as:<br><br>\\( A = QR \\)<br><br>Where:<br><br><ul><li>\\( Q \\) is \\( m \\times n \\) with orthonormal columns</li><li>\\( R \\) is \\( n \\times n \\) upper triangular</li></ul>",
      "tags": [
        "ch29",
        "qr",
        "definition"
      ]
    },
    {
      "uid": "linear-algebra-29-002",
      "front": "How does QR relate to Gram-Schmidt?",
      "back": "Gram-Schmidt orthogonalizes columns of \\( A \\) to get columns of \\( Q \\).<br><br>\\( R \\) contains the coefficients: \\( r_{ij} = \\vec{q}_i^T \\vec{a}_j \\)<br><br>Classical Gram-Schmidt is numerically unstable; use modified Gram-Schmidt or Householder.",
      "tags": [
        "ch29",
        "qr",
        "gram-schmidt"
      ]
    },
    {
      "uid": "linear-algebra-29-003",
      "front": "What is the Householder QR algorithm?",
      "back": "Uses Householder reflections to zero out below-diagonal entries column by column.<br><br>\\( A \\to H_1 A \\to H_2 H_1 A \\to ... \\to R \\)<br><br>Then \\( Q = H_1 H_2 ... H_{n-1} \\).<br><br>Numerically stable and preferred in practice.",
      "tags": [
        "ch29",
        "householder",
        "algorithm"
      ]
    },
    {
      "uid": "linear-algebra-29-004",
      "front": "Why is QR more numerically stable than normal equations for least squares?",
      "back": "Normal equations form \\( A^T A \\), which squares the condition number.<br><br>QR solves \\( R\\hat{x} = Q^T \\vec{b} \\) directly, preserving the original condition number.<br><br>Rule of thumb: if \\( A \\) has condition number \\( \\kappa \\), \\( A^T A \\) has \\( \\kappa^2 \\).",
      "tags": [
        "ch29",
        "numerical-stability",
        "least-squares"
      ]
    },
    {
      "uid": "linear-algebra-29-005",
      "front": "When should you use QR vs SVD vs eigendecomposition?",
      "back": "QR: solving least squares, finding orthonormal bases (fast)<br><br>SVD: rank determination, pseudoinverse, low-rank approximation (robust)<br><br>Eigendecomposition: only for square matrices; symmetric case for spectral analysis",
      "tags": [
        "ch29",
        "comparison",
        "use-cases"
      ]
    },
    {
      "uid": "linear-algebra-29-006",
      "front": "What is the computational cost of QR vs SVD?",
      "back": "For \\( m \\times n \\) matrix (\\( m \\geq n \\)):<br><br>QR: \\( O(mn^2) \\)<br><br>SVD: \\( O(mn^2 + n^3) \\) or \\( O(m^2n + n^3) \\)<br><br>QR is cheaper; use SVD when you need singular values/vectors.",
      "tags": [
        "ch29",
        "complexity",
        "comparison"
      ]
    },
    {
      "uid": "linear-algebra-29-007",
      "front": "What is the thin QR vs full QR decomposition?",
      "back": "Thin (reduced): \\( A = Q_1 R_1 \\) where \\( Q_1 \\) is \\( m \\times n \\), \\( R_1 \\) is \\( n \\times n \\)<br><br>Full: \\( A = Q R \\) where \\( Q \\) is \\( m \\times m \\) orthogonal, \\( R \\) is \\( m \\times n \\)<br><br>Thin is more efficient and usually sufficient.",
      "tags": [
        "ch29",
        "qr",
        "variants"
      ]
    },
    {
      "uid": "linear-algebra-29-008",
      "front": "How does QR help with eigenvalue computation?",
      "back": "The QR algorithm iterates:<br><br>\\( A_k = Q_k R_k \\), then \\( A_{k+1} = R_k Q_k \\)<br><br>\\( A_k \\) converges to upper triangular with eigenvalues on diagonal.<br><br>This is how eigenvalues are computed in practice.",
      "tags": [
        "ch29",
        "qr-algorithm",
        "eigenvalues"
      ]
    },
    {
      "uid": "linear-algebra-29-009",
      "front": "What is backward stability in numerical linear algebra?",
      "back": "An algorithm is backward stable if the computed answer is the exact answer to a slightly perturbed problem.<br><br>Householder QR is backward stable: computed \\( \\hat{Q}\\hat{R} = A + E \\) where \\( ||E|| \\) is small.<br><br>This is the gold standard for numerical algorithms.",
      "tags": [
        "ch29",
        "backward-stability",
        "numerical"
      ]
    },
    {
      "uid": "linear-algebra-29-010",
      "front": "Why does numerical stability matter for MI?",
      "back": "Model weights are already imprecise (float32/float16).<br><br>Unstable algorithms amplify errors:<br><br><ul><li>Decompositions of large weight matrices</li><li>Extracting small singular values</li><li>Computing in ill-conditioned regimes</li></ul><br>Use QR or SVD rather than naive methods.",
      "tags": [
        "ch29",
        "numerical-stability",
        "mi-application"
      ]
    }
  ]
}
